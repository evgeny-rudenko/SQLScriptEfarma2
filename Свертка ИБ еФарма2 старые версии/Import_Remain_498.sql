-- USE EPLUS_DEV10
/* Для ускорения работы процы:
    - удалить индексы до заливки, создать после
    - отключить триггеры на таблицах LOT_MOVEMENT и LOT, включить после 
    - работу триггеров на LOT_MOVEMENT и LOT сделать в этой проце явно
    - LOT.LOT_NAME считать сразу для всех лотов после их создания
    - отключить проверку ограничений до вставки данных, включить после
*/
SET NOCOUNT ON
SET ANSI_NULLS ON 
GO
IF OBJECT_ID('[DBO].USP_REMAINS_IMPORT_1C') IS NULL BEGIN
    EXEC('CREATE PROCEDURE [DBO].USP_REMAINS_IMPORT_1C AS RETURN')
    GRANT EXEC ON [DBO].[USP_REMAINS_IMPORT_1C] TO [PUBLIC]
END
GO
ALTER PROCEDURE [DBO].USP_REMAINS_IMPORT_1C AS

SET NOCOUNT ON


IF OBJECT_ID('_IMPORT_REMAINS') IS NOT NULL BEGIN
    CREATE INDEX IX1 ON _IMPORT_REMAINS (CODE_CONTR)
    CREATE INDEX IX2 ON _IMPORT_REMAINS (OUTER_CODE)
    CREATE INDEX IX3 ON _IMPORT_REMAINS (SKLAD)
    CREATE INDEX IX4 ON _IMPORT_REMAINS (DELEN)
    CREATE INDEX IX5 ON _IMPORT_REMAINS (TAXRATER)
    CREATE INDEX IX6 ON _IMPORT_REMAINS (TAXRATES)
END ELSE BEGIN
    SELECT 'ОТСУТСТВУЮТ ДАННЫЕ ОБ ОСТАТКАХ'
    RETURN -1
END

UPDATE _IMPORT_REMAINS SET 
    CODE_CONTR = RTRIM(LTRIM(CODE_CONTR)),
    OUTER_CODE = RTRIM(LTRIM(OUTER_CODE))

DECLARE @DATE DATETIME
SELECT @DATE = GETDATE()

--* СОДЕРЖИТ КАТАЛОГ 
DECLARE @ID_FOLDER INTEGER
--* ПРОФАЙЛ ПОЛЬЗОВАТЕЛЯ
DECLARE @ID_USER INTEGER
--* МОДЕЛЬ ЦЕНООБРАЗОВАНИЯ
DECLARE @ID_PRICING_PRICING_MODEL BIGINT
--* ПЕРВИЧНАЯ УПАКОВКА
DECLARE @DEFAULT_UNIT BIGINT
SELECT TOP 1 @DEFAULT_UNIT = ID_UNIT FROM UNIT WHERE MNEMOCODE = 'PBOX'
IF @DEFAULT_UNIT IS NULL BEGIN
    INSERT [UNIT]([NAME], [DESCRIPTION], [MNEMOCODE], [SHORT_NAME], [OKEI_CODE], [DATE_MODIFIED])
    VALUES('Первичная упаковка', 'Первичная упаковка', 'PBOX', 'перв. уп.', '234', @DATE)
    SET @DEFAULT_UNIT = SCOPE_IDENTITY()
END
-- ПОЛУЧЕНИЕ СИСТЕМНЫХ КОНСТАНТ 
--SELECT TOP 1 @ID_FOLDER = ID_FOLDER FROM FOLDER WHERE ID_PARENT_FOLDER IS NULL AND ID_FOLDER > 0
SET @ID_FOLDER = 1
--SELECT TOP 1 @ID_USER = ID_USER FROM [USER] WHERE NAME = '1'
SET @ID_USER = 1
SELECT TOP 1 @ID_PRICING_PRICING_MODEL = ID_PRICING_PRICING_MODEL 
FROM PRICING_PRICING_MODEL 
WHERE LTRIM(RTRIM([NAME])) = 'Обычная Розница'

IF @ID_FOLDER IS NULL OR @ID_USER IS NULL OR @ID_PRICING_PRICING_MODEL IS NULL BEGIN
    SELECT 'ЗАВЕРШЕНИЕ ИМПОРТА НЕВОЗМОЖНО - НЕКОРРЕКТНО ЗАДАНЫ КОНСТАНТЫ:'
    SELECT 'ПАПКА: ' + ISNULL(CONVERT(VARCHAR, @ID_FOLDER), 'НЕ ОПРЕДЕЛЕНА')
    SELECT 'ПРОФАЙЛ ПОЛЬЗОВАТЕЛЯ: ' + ISNULL(CONVERT(VARCHAR, @ID_USER), 'НЕ ОПРЕДЕЛЕН')
    SELECT 'МОДЕЛЬ ЦЕНООБРАЗОВАНИЯ: ' + ISNULL(CONVERT(VARCHAR, @ID_PRICING_PRICING_MODEL), 'НЕ ОПРЕДЕЛЕНА')
    RETURN -1
END

DECLARE @ERRSTRING VARCHAR(255)
DECLARE @NUMBER INT
DECLARE @ID_INVOICE BIGINT
DECLARE @ID_INVOICE_GLOBAL UNIQUEIDENTIFIER
DECLARE @MNEMOCODE VARCHAR(40)
DECLARE @QUANTITY MONEY
DECLARE @ID_GOODS INT 
DECLARE @ID_SCALING_RATIO BIGINT
DECLARE @ID_INVOICE_ITEM_GLOBAL UNIQUEIDENTIFIER
DECLARE @ID_LOT_GLOBAL UNIQUEIDENTIFIER
DECLARE @ID_CONTRACTOR BIGINT
DECLARE @ID_STORE BIGINT
DECLARE @SERIES VARCHAR(30)
DECLARE @BESTBEFORE DATETIME
DECLARE @ID_SERIES BIGINT
DECLARE @PROD_PRICE MONEY
DECLARE @PROD_PRICE_VAT MONEY
DECLARE @SUP_PRICE MONEY
DECLARE @SUP_PRICE_VAT MONEY
DECLARE @RET_PRICE MONEY
DECLARE @RET_PRICE_VAT MONEY
DECLARE @SUP_VAT_RATE INT
DECLARE @RET_VAT_RATE INT
DECLARE @SUP_ID_TAX_TYPE BIGINT
DECLARE @RET_ID_TAX_TYPE BIGINT
DECLARE @GLOBAL_IDENTIFIER UNIQUEIDENTIFIER
DECLARE @INTERNAL_BARCODE VARCHAR(13)
DECLARE @BAR_CODE VARCHAR(256)
DECLARE @GTD_NUMBER VARCHAR(100)

-- удаление индексов
-- LOT
IF  EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'LOT$ID_GOODS')
    DROP INDEX LOT.[LOT$ID_GOODS]
IF EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'LOT$ID_STORE')
    DROP  INDEX LOT.[LOT$ID_STORE]
IF EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'LOT$ID_SUPPLIER')
    DROP  INDEX LOT.[LOT$ID_SUPPLIER]
IF EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'LOT$ID_SCALING_RATIO')
    DROP  INDEX LOT.[LOT$ID_SCALING_RATIO]
-- IF EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'LOT$ID_LOT_GLOBAL')    -- мешают FK
--     DROP  INDEX LOT.[LOT$ID_LOT_GLOBAL]
-- INVOICE_ITEM
IF EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'IX_INVOICE_ITEM$ID_INVOICE')
    DROP  INDEX INVOICE_ITEM.[IX_INVOICE_ITEM$ID_INVOICE]
IF EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'IX_INVOICE_ITEM$ID_INVOICE_GLOBAL')
    DROP  INDEX INVOICE_ITEM.[IX_INVOICE_ITEM$ID_INVOICE_GLOBAL] 
IF EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'IX_INVOICE_ITEM$ID_SCALING_RATIO')
    DROP  INDEX INVOICE_ITEM.[IX_INVOICE_ITEM$ID_SCALING_RATIO]
IF EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'IX_INVOICE_ITEM$ID_SERIES')
    DROP  INDEX INVOICE_ITEM.[IX_INVOICE_ITEM$ID_SERIES]
--SERIES
IF OBJECT_ID('SERIES_AK1') IS NOT NULL
    ALTER TABLE [dbo].[SERIES] DROP CONSTRAINT [SERIES_AK1] 
IF EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'IX_SERIES$ID_GOODS')
    DROP  INDEX SERIES.[IX_SERIES$ID_GOODS]
-- ОТКЛЮЧИТЬ ПРОВЕРКУ ОГРАНИЧЕНИЙ
ALTER TABLE INVOICE_ITEM NOCHECK CONSTRAINT ALL
ALTER TABLE LOT NOCHECK CONSTRAINT ALL
ALTER TABLE LOT_MOVEMENT NOCHECK CONSTRAINT ALL
ALTER TABLE SERIES NOCHECK CONSTRAINT ALL

-- ПОДГОТОВИТЕЛЬНЫЕ ДЕЙСТВИЯ
-- ДОБАВЛЕЛНИЕ ЕДИНИЦ ИЗМЕРЕНИЯ, ЕСЛИ ИХ ЕЩЕ НЕТ В СИСТЕМЕ
INSERT SCALING_RATIO(
    NUMERATOR, DENOMINATOR, ID_UNIT, ID_GOODS, DATE_MODIFIED
)
SELECT DISTINCT
    1, R.DELEN, @DEFAULT_UNIT, G.ID_GOODS, @DATE
FROM _IMPORT_REMAINS R
   INNER JOIN GOODS G ON CAST(CAST(R.OUTER_CODE AS BIGINT) AS VARCHAR(20)) = G.MNEMOCODE
   LEFT JOIN SCALING_RATIO SR ON SR.ID_GOODS = G.ID_GOODS AND SR.DENOMINATOR = R.DELEN
WHERE SR.ID_SCALING_RATIO IS NULL

-- ПОЛУЧЕНИЕ НЕНОРМАЛИЗОВАННЫХ ДАННЫХ
IF OBJECT_ID('TEMPDB..#IMPORT_NAKL') IS NOT NULL BEGIN
    DROP TABLE #IMPORT_NAKL
END

SELECT
    N.CODE_CONTR, N.OUTER_CODE,
    N.QUANTITY,
    N.DELEN,
    LTRIM(RTRIM(N.SERIES)) AS SERIES,
    N.BESTBEFORE,
    N.SUP_PRICE,
    N.RET_PRICE,
    N.TAXRATER,
    N.TAXRATES,
    N.PROD_PRICE,
    N.SKLAD,
    N.SHTRIHC,
    C.ID_CONTRACTOR,
    G.ID_GOODS,
    SR.ID_SCALING_RATIO,
    TTR.ID_TAX_TYPE AS R_TAX_TYPE,
    TTS.ID_TAX_TYPE AS S_TAX_TYPE,
    S.ID_STORE,
    N.SHTRIHC AS BAR_CODE,
	N.GTD_NUMBER,
    CAST(NULL AS BIGINT) AS ID_SERIES_LOC,    -- локальный код серии
    CAST(NULL AS BIGINT) AS ID_INVOICE,       -- код накладной 
    NEWID() AS ID_INVOICE_ITEM_GLOBAL,        -- код строки накладной   
    ROUND(PROD_PRICE /(1 + CAST(TAXRATES AS MONEY)/100), 2) AS PROD_PRICE_WITHOUT_VAT,
    ROUND(SUP_PRICE /(1 + CAST(TAXRATES AS MONEY)/100), 2) AS SUP_PRICE_WITHOUT_VAT,
    ROUND(RET_PRICE /(1 + CAST(TAXRATER AS MONEY)/100), 2) AS RET_PRICE_WITHOUT_VAT,
    N.CERT AS CERTIFICATE,
	N.CERT_DATE AS CERTIFICATE_DATE
INTO #IMPORT_NAKL
FROM _IMPORT_REMAINS N
    LEFT JOIN CONTRACTOR C ON C.MNEMOCODE = CONVERT(VARCHAR, N.CODE_CONTR)
    LEFT JOIN GOODS G ON G.MNEMOCODE = CAST(CAST(N.OUTER_CODE AS BIGINT) AS VARCHAR(20))
    LEFT JOIN SCALING_RATIO SR ON SR.ID_GOODS = G.ID_GOODS AND SR.DENOMINATOR = N.DELEN AND SR.NUMERATOR = 1
    LEFT JOIN TAX_TYPE TTR ON N.TAXRATER = TTR.TAX_RATE
    LEFT JOIN TAX_TYPE TTS ON N.TAXRATES = TTS.TAX_RATE
    LEFT JOIN STORE S ON LTRIM(RTRIM(N.SKLAD)) = S.MNEMOCODE

CREATE INDEX IX1 ON #IMPORT_NAKL (ID_CONTRACTOR)
CREATE INDEX IX4 ON #IMPORT_NAKL (ID_STORE)
-- CREATE INDEX IX2 ON #IMPORT_NAKL (ID_GOODS)
-- CREATE INDEX IX3 ON #IMPORT_NAKL (ID_SCALING_RATIO)
-- CREATE INDEX IX5 ON #IMPORT_NAKL (R_TAX_TYPE)
-- CREATE INDEX IX6 ON #IMPORT_NAKL (S_TAX_TYPE)
-- CREATE INDEX IX7 ON #IMPORT_NAKL (BAR_CODE)

--* ЧИЩУ ДАННЫЕ
IF EXISTS(SELECT TOP 1 1 FROM #IMPORT_NAKL 
    WHERE ID_GOODS IS NULL OR ID_SCALING_RATIO IS NULL OR ID_CONTRACTOR IS NULL OR QUANTITY <= 0 OR ID_STORE IS NULL) 
BEGIN
    SELECT 'УДАЛЕНИЕ ТЕХ ПОЗИЦИИ, В КОТОРЫХ ИСПОЛЬЗУЕТСЯ'
    SELECT '1. НЕИЗВЕСТНЫЙ КОД ТОВАРА'
    SELECT '2. НЕИЗВЕСТЕН ДЕНОМИНАТОР'
    SELECT '3. НЕИЗВЕСТЕН КОД ПОСТАВЩИКА'
    SELECT '4. КОЛ-ВО МЕНЬШЕ ЛИБО РАВНО 0'
    SELECT '5. НЕИЗВЕСТНЫЙ КОД СКЛАДА'
    SELECT '----------------------------------------------------------------------------------------------'
END

-- СПЕРВА ОТОБРАЖЕНИЕ ТОГО, ЧТО НУЖНО УДАЛЯТЬ

SELECT
    'СКЛАД: ' + ISNULL(I.SKLAD,'') +
    'ТОВАР: ' + ISNULL(G.NAME,'') +
    'БАР-КОД: ' + ISNULL(I.SHTRIHC, '') +
    ' СЕРИЯ: ' + ISNULL(I.SERIES, '') +
    ' СУММА: ' + CONVERT(VARCHAR, I.QUANTITY * I.RET_PRICE) +
    ' ПРИЧИНЫ: ' + 
    CASE WHEN I.ID_GOODS IS NULL THEN 'НЕИЗВЕСТНЫЙ КОД ТОВАРА: ' + CAST(CAST(I.OUTER_CODE AS BIGINT) AS VARCHAR(20)) +'; ' ELSE '' END +
    CASE WHEN I.ID_SCALING_RATIO IS NULL THEN 'НЕКОРРЕКТНЫЙ ДЕНОМИНАТОР: ' + CONVERT(VARCHAR, I.DELEN)+'; ' ELSE '' END +
    CASE WHEN I.QUANTITY <= 0 THEN 'НЕКОРРЕКТНОЕ КОЛИЧЕСТВО: ' + CONVERT(VARCHAR, I.QUANTITY)+'; ' ELSE '' END +
    CASE WHEN I.ID_CONTRACTOR IS NULL THEN 'НЕИЗВЕСТНЫЙ ПОСТАВЩИК: ' + CONVERT(VARCHAR, I.CODE_CONTR) +'; ' ELSE '' END +
    CASE WHEN I.ID_STORE IS NULL THEN 'НЕИЗВЕСТНЫЙ КОД СКЛАДА: ' + I.SKLAD +'; ' ELSE '' END
FROM #IMPORT_NAKL I
    LEFT JOIN GOODS G ON I.ID_GOODS = G.ID_GOODS
WHERE  I.ID_GOODS IS NULL
    OR I.ID_SCALING_RATIO IS NULL
    OR I.ID_CONTRACTOR IS NULL 
    OR I.QUANTITY <= 0
    OR I.ID_STORE IS NULL
ORDER BY ISNULL(I.SKLAD,''), ISNULL(G.NAME,'')

-- ТЕПЕРЬ УДАЛЕНИЕ
DELETE FROM #IMPORT_NAKL 
WHERE  ID_GOODS IS NULL
    OR ID_SCALING_RATIO IS NULL
    OR ID_CONTRACTOR IS NULL 
    OR QUANTITY <= 0
    OR ID_STORE IS NULL

SET @NUMBER = 0

-- создать серии (определяются по ID_GOODS и SERIES_NUMBER)
INSERT INTO SERIES (ID_GOODS, BEST_BEFORE, SERIES_NUMBER, MNEMOCODE,DATE_DELETED, DATE_MODIFIED)
    SELECT ID_GOODS, MAX(BESTBEFORE), SERIES, CONVERT(VARCHAR(36), NEWID()), NULL, @DATE
    FROM #IMPORT_NAKL
    GROUP BY ID_GOODS, SERIES
-- записать коды созданных серий в #IMPORT_NAKL
UPDATE I
SET ID_SERIES_LOC = S.ID_SERIES
FROM #IMPORT_NAKL I
    INNER JOIN SERIES S ON I.ID_GOODS = S.ID_GOODS AND I.SERIES = S.SERIES_NUMBER

INSERT INTO CERTIFICATE (CERT_NUMBER, CERT_DATE, ID_SERIES)
	SELECT CERTIFICATE, CERTIFICATE_DATE, ID_SERIES_LOC
	FROM #IMPORT_NAKL
	WHERE CERTIFICATE IS NOT NULL AND CERTIFICATE <> ''

-- Отлючить триггер на таблице LOT_MOVEMENT
ALTER TABLE LOT_MOVEMENT DISABLE TRIGGER TR_LOT_MOVEMENT
-- Отлючить триггер на таблице LOT_MOVEMENT
ALTER TABLE LOT DISABLE TRIGGER TR_LOT

-- Сколько накладных должно создаться
DECLARE @NUMBER_TOTAL INT
IF OBJECT_ID('#INV') IS NOT NULL DROP TABLE #INV
SELECT ID_CONTRACTOR
INTO #INV
FROM #IMPORT_NAKL
GROUP BY ID_CONTRACTOR, ID_STORE
SELECT @NUMBER_TOTAL = COUNT(*) FROM #INV

SELECT 'СОЗДАНИЕ ПРИХОДНЫХ НАКЛАДНЫХ'
SELECT 'ДОЛЖНО БЫТЬ СОЗДАНО ' + CAST(@NUMBER_TOTAL AS VARCHAR(20)) + ' ПРИХОДНЫХ НАКЛАДНЫХ'

-- СОЗДАНИЕ НАКЛАДНЫХ
DECLARE CUR CURSOR FAST_FORWARD FOR
    SELECT ID_CONTRACTOR, ID_STORE
    FROM #IMPORT_NAKL
    GROUP BY ID_CONTRACTOR, ID_STORE
OPEN CUR
WHILE 1 = 1 BEGIN
    FETCH NEXT FROM CUR INTO @ID_CONTRACTOR, @ID_STORE
    IF @@FETCH_STATUS != 0 BREAK
    SELECT @NUMBER = @NUMBER + 1
    EXEC USP_MNEMOCODE_GEN @MNEMOCODE OUT, 'INVOICE'
    SET @ID_INVOICE_GLOBAL = NEWID()
    -- СОЗДАНИЕ НАКЛАДНОЙ
    SELECT 'СОЗДАНИЕ ПРИХОДНОЙ НАКЛАДНОЙ ' + CAST(@NUMBER AS VARCHAR(20)) + ' ИЗ ' + + CAST(@NUMBER_TOTAL AS VARCHAR(20))
    
    INSERT INTO INVOICE (
        ID_INVOICE_GLOBAL, ID_CONTRACTOR_SUPPLIER, INCOMING_NUMBER, INCOMING_DATE, INCOMING_BILL_NUMBER,
        INCOMING_BILL_DATE, DATE_MODIFIED, COMMENT, MNEMOCODE, DOCUMENT_STATE, DOCUMENT_DATE, ID_STORE, ID_FOLDER,
        ID_USER, SVAT_SUPPLIER, SUM_SUPPLIER, SVAT_RETAIL, SUM_RETAIL, ID_PRICING_PRICING_MODEL
    )
    VALUES(
        @ID_INVOICE_GLOBAL, @ID_CONTRACTOR, CONVERT(VARCHAR(40), @NUMBER), @DATE, NULL,
        NULL, @DATE, 'Перенос остатков из 1C', @MNEMOCODE, 'PROC', @DATE, @ID_STORE, @ID_FOLDER,
        @ID_USER, 0, 0, 0, 0, @ID_PRICING_PRICING_MODEL
    )
    IF @@ERROR != 0 BEGIN          
        SELECT 'Ошибка при создании приходной накладной ' + CAST(@NUMBER AS VARCHAR(20)) + ' ИЗ ' + + CAST(@NUMBER_TOTAL AS VARCHAR(20))
        GOTO NEXT_STEP
    END
    SET @ID_INVOICE = SCOPE_IDENTITY()
    -- прописать код накладной во времянке
    UPDATE #IMPORT_NAKL SET ID_INVOICE = @ID_INVOICE
    WHERE ID_CONTRACTOR = @ID_CONTRACTOR AND ID_STORE = @ID_STORE

        BEGIN TRAN
        -- ВСТАВКА СТРОК НАКЛАДНОЙ
            INSERT INTO INVOICE_ITEM(
                ID_INVOICE, ID_INVOICE_GLOBAL,
                QUANTITY, ID_SCALING_RATIO, 
                PRODUCER_PRICE,
                SUPPLIER_ADPRICE, 
                SUPPLIER_PRICE, 
                SUPPLIER_PRICE_VAT, 
                SUPPLIER_VAT_SUM, 
                SUPPLIER_SUM, 
                SUPPLIER_SUM_VAT,
                RETAIL_ADPRICE, 
                RETAIL_PRICE, 
                RETAIL_PRICE_VAT, 
                RETAIL_VAT_SUM, 
                RETAIL_SUM, 
                RETAIL_SUM_VAT,
                BAR_CODE, ID_STORE_PLACE, ID_SERIES, ID_GOODS, GTD_NUMBER,
                SUPPLIER_VAT, 
                RETAIL_VAT, 
                ID_INVOICE_ITEM_GLOBAL,
				VAT				
            )
            SELECT 
                @ID_INVOICE, @ID_INVOICE_GLOBAL, 
                QUANTITY, ID_SCALING_RATIO, 
                PROD_PRICE_WITHOUT_VAT,
                SUP_PRICE_WITHOUT_VAT - PROD_PRICE_WITHOUT_VAT, 
                SUP_PRICE_WITHOUT_VAT, 
                SUP_PRICE, 
                QUANTITY * (SUP_PRICE - SUP_PRICE_WITHOUT_VAT),    
                QUANTITY * SUP_PRICE_WITHOUT_VAT,   
                QUANTITY * SUP_PRICE,  
                (RET_PRICE - SUP_PRICE)/SUP_PRICE * 100, --%наценки  --RET_PRICE_WITHOUT_VAT - SUP_PRICE_WITHOUT_VAT,  
                RET_PRICE_WITHOUT_VAT, 
                RET_PRICE, 
                QUANTITY * (RET_PRICE - RET_PRICE_WITHOUT_VAT),
                QUANTITY * RET_PRICE_WITHOUT_VAT,
                QUANTITY * RET_PRICE, 
                BAR_CODE, NULL, ID_SERIES_LOC, ID_GOODS, GTD_NUMBER,
                TAXRATES, 
                TAXRATER, 
                ID_INVOICE_ITEM_GLOBAL,
				TAXRATES				
            FROM #IMPORT_NAKL 
            WHERE ID_CONTRACTOR = @ID_CONTRACTOR AND ID_STORE = @ID_STORE 
	
	        -- ВСТАВКА ПАРТИЙ 
            INSERT LOT(
                ID_STORE, ID_GOODS, ID_SUPPLIER, ID_SERIES, ID_SCALING_RATIO, ID_PARENT,
                QUANTITY_ADD, QUANTITY_SUB, QUANTITY_RES, QUANTITY_REM,
                PRICE_PROD, VAT_PROD, PVAT_PROD ,
                PRICE_SUP, VAT_SUP, PVAT_SUP,
                PRICE_SAL, VAT_SAL, PVAT_SAL,
                ID_TABLE, ID_DOCUMENT, ID_DOCUMENT_ITEM, LOT_NAME, 
                INTERNAL_BARCODE,
				VAT
            )
            SELECT 
                @ID_STORE, ID_GOODS, @ID_CONTRACTOR, ID_SERIES_LOC, ID_SCALING_RATIO, NULL,
                0, 0, 0, 0,
                PROD_PRICE, TAXRATES, PROD_PRICE * TAXRATES / (100 + TAXRATES),
                SUP_PRICE, TAXRATES,  SUP_PRICE * TAXRATES / (100 + TAXRATES),
                RET_PRICE, TAXRATER, RET_PRICE * TAXRATER / (100 + TAXRATER),
                2, @ID_INVOICE_GLOBAL, ID_INVOICE_ITEM_GLOBAL, CONVERT(VARCHAR(36) , NEWID()), 
                SHTRIHC, 
				TAXRATES 
            FROM #IMPORT_NAKL 
            WHERE ID_CONTRACTOR = @ID_CONTRACTOR AND ID_STORE = @ID_STORE  

            IF @@ERROR != 0 BEGIN          
                SELECT @ERRSTRING = 'ОШИБКА ПРИ СОЗДАНИИ ПАРТИЙ ПО ПРИХОДНОЙ НАКЛАДНОЙ '  + CAST(@NUMBER AS VARCHAR(20)) + ' ИЗ ' + + CAST(@NUMBER_TOTAL AS VARCHAR(20))
                GOTO ERRORHANDLER 
            END

            -- СОЗДАНИЕ ПРОВОДОК 
            /*INSERT LOT_MOVEMENT(
                ID_LOT_GLOBAL, DATE_OP, CODE_OP,
                QUANTITY_ADD, QUANTITY_SUB, QUANTITY_RES,
                ID_TABLE, ID_DOCUMENT, ID_DOCUMENT_ITEM,
                SVAT_SUP, SUM_SUP, SUM_ACC, SVAT_ACC, DISCOUNT_ACC
            )
            SELECT
                L.ID_LOT_GLOBAL, @DATE, 'INVOICE',
                II.QUANTITY, 0, 0,
                2, L.ID_DOCUMENT, L.ID_DOCUMENT_ITEM,
                II.SUPPLIER_PRICE_VAT * QUANTITY_ADD, II.SUPPLIER_PRICE * L.QUANTITY_ADD, 0, 0, 0
            FROM LOT L
                INNER JOIN INVOICE_ITEM II ON L.ID_DOCUMENT_ITEM = II.ID_INVOICE_ITEM_GLOBAL 
            WHERE II.ID_INVOICE = @ID_INVOICE*/
            
			INSERT INTO LOT_MOVEMENT(
				ID_LOT_GLOBAL, DATE_OP, CODE_OP,
				QUANTITY_ADD, QUANTITY_SUB, QUANTITY_RES,
				SVAT_SUP, SUM_SUP, DISCOUNT_ACC, SVAT_ACC, SUM_ACC,
				ID_TABLE, ID_DOCUMENT, ID_DOCUMENT_ITEM 
			)
			SELECT
				L.ID_LOT_GLOBAL, I.DOCUMENT_DATE, 'INVOICE',
				II.QUANTITY, 0, 0,
				II.SUPPLIER_VAT_SUM, II.SUPPLIER_SUM_VAT, 0, II.RETAIL_VAT_SUM, II.RETAIL_SUM_VAT,
				2, L.ID_DOCUMENT, L.ID_DOCUMENT_ITEM
			FROM INVOICE_ITEM II(NOLOCK)
				INNER JOIN INVOICE I(NOLOCK) ON I.ID_INVOICE_GLOBAL = II.ID_INVOICE_GLOBAL
				INNER JOIN LOT L(NOLOCK) ON L.ID_DOCUMENT = I.ID_INVOICE_GLOBAL AND L.ID_DOCUMENT_ITEM = II.ID_INVOICE_ITEM_GLOBAL
			WHERE I.ID_INVOICE_GLOBAL = @ID_INVOICE_GLOBAL 
			
            IF @@ERROR != 0 BEGIN          
               SELECT @ERRSTRING = 'ОШИБКА ПРИ СОЗДАНИИ ПРОВОДОК ПО ПРИХОДНОЙ НАКЛАДНОЙ '  + CAST(@NUMBER AS VARCHAR(20)) + ' ИЗ ' + + CAST(@NUMBER_TOTAL AS VARCHAR(20))
               GOTO ERRORHANDLER 
            END
			/*
			UPDATE INVOICE SET
				DOCUMENT_STATE = 'PROC', 
				DATE_MODIFIED = GETDATE()
			WHERE ID_INVOICE_GLOBAL = @ID_INVOICE_GLOBAL
            */
        IF @@TRANCOUNT > 0 COMMIT TRAN
        GOTO CTU
    
        ERRORHANDLER:
        IF @@TRANCOUNT > 0 ROLLBACK TRAN  
        SELECT @ERRSTRING
    
        CTU:
    
    UPDATE INVOICE SET
        SVAT_SUPPLIER = (SELECT SUM(SUPPLIER_VAT_SUM) FROM INVOICE_ITEM WHERE ID_INVOICE = @ID_INVOICE) ,
        SUM_SUPPLIER = (SELECT SUM(SUPPLIER_SUM_VAT) FROM INVOICE_ITEM WHERE ID_INVOICE = @ID_INVOICE) ,
        SVAT_RETAIL = (SELECT SUM(RETAIL_VAT_SUM) FROM INVOICE_ITEM WHERE ID_INVOICE = @ID_INVOICE) ,
        SUM_RETAIL = (SELECT SUM(RETAIL_SUM_VAT) FROM INVOICE_ITEM WHERE ID_INVOICE = @ID_INVOICE)
    WHERE ID_INVOICE = @ID_INVOICE
                
NEXT_STEP:
END    
CLOSE CUR
DEALLOCATE CUR

-- СОЗДАНИЕ ИНДЕКСОВ
-- LOT
IF NOT EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'LOT$ID_GOODS')
    CREATE  INDEX [LOT$ID_GOODS] ON [DBO].[LOT]([ID_GOODS]) ON [PRIMARY]
IF NOT EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'LOT$ID_STORE')
    CREATE  INDEX [LOT$ID_STORE] ON [DBO].[LOT]([ID_STORE]) ON [PRIMARY]
IF NOT EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'LOT$ID_SUPPLIER')
    CREATE  INDEX [LOT$ID_SUPPLIER] ON [DBO].[LOT]([ID_SUPPLIER]) ON [PRIMARY]
IF NOT EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'LOT$ID_SCALING_RATIO')
    CREATE  INDEX [LOT$ID_SCALING_RATIO] ON [DBO].[LOT]([ID_SCALING_RATIO]) ON [PRIMARY]

-- INVOICE_ITEM
IF NOT EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'IX_INVOICE_ITEM$ID_INVOICE')
    CREATE  INDEX [IX_INVOICE_ITEM$ID_INVOICE] ON [DBO].[INVOICE_ITEM]([ID_INVOICE]) ON [PRIMARY]
IF NOT EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'IX_INVOICE_ITEM$ID_INVOICE_GLOBAL')
    CREATE  INDEX [IX_INVOICE_ITEM$ID_INVOICE_GLOBAL] ON [DBO].[INVOICE_ITEM]([ID_INVOICE_GLOBAL]) ON [PRIMARY]
IF NOT EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'IX_INVOICE_ITEM$ID_SCALING_RATIO')
    CREATE  INDEX [IX_INVOICE_ITEM$ID_SCALING_RATIO] ON [DBO].[INVOICE_ITEM]([ID_SCALING_RATIO]) ON [PRIMARY]
IF NOT EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'IX_INVOICE_ITEM$ID_SERIES')
    CREATE  INDEX [IX_INVOICE_ITEM$ID_SERIES] ON [DBO].[INVOICE_ITEM]([ID_SERIES]) ON [PRIMARY]

--SERIES
IF OBJECT_ID('SERIES_AK1') IS NULL
    ALTER TABLE [DBO].[SERIES] ADD CONSTRAINT [SERIES_AK1] UNIQUE  NONCLUSTERED ([MNEMOCODE])
IF NOT EXISTS(SELECT 1 FROM SYSINDEXES WHERE NAME = 'IX_SERIES$ID_SERIES')
    CREATE  INDEX [IX_SERIES$ID_GOODS] ON [DBO].[SERIES]([ID_GOODS]) ON [PRIMARY]

-- СДЕЛАТЬ РАБОТУ ТРИГГЕРА TR_LOT_MOVEMENT
-- ЗАЛИВКА В ПРОМЕЖУТОЧНУЮ ТАБЛИЦУ
DECLARE @TOTALS TABLE  (ID_STORE BIGINT, 
                        ID_GOODS BIGINT, 
                        ID_SUPPLIER BIGINT,
	                    QUANTITY_ADD MONEY, 
                        QUANTITY_SUB MONEY, 
                        QUANTITY_RES MONEY)
INSERT INTO @TOTALS (ID_STORE, ID_GOODS, ID_SUPPLIER, 
	QUANTITY_ADD, QUANTITY_SUB, QUANTITY_RES)
	SELECT LOT.ID_STORE, LOT.ID_GOODS, LOT.ID_SUPPLIER,
		QUANTITY_ADD = SUM(CONVERT(FLOAT, MOV.QUANTITY_ADD) * SR.NUMERATOR / SR.DENOMINATOR), 
		QUANTITY_SUB = SUM(CONVERT(FLOAT, MOV.QUANTITY_SUB) * SR.NUMERATOR / SR.DENOMINATOR),
		QUANTITY_RES = SUM(CONVERT(FLOAT, MOV.QUANTITY_RES) * SR.NUMERATOR / SR.DENOMINATOR)
	FROM LOT_MOVEMENT MOV
	INNER JOIN LOT ON LOT.ID_LOT_GLOBAL = MOV.ID_LOT_GLOBAL
	INNER JOIN SCALING_RATIO SR ON SR.ID_SCALING_RATIO = LOT.ID_SCALING_RATIO
	GROUP BY LOT.ID_STORE, LOT.ID_GOODS, LOT.ID_SUPPLIER

-- ВСТАВКА НОВЫХ СТРОК
INSERT INTO STOCK_RECORD (ID_STORE, ID_GOODS, ID_SUPPLIER,
QUANTITY_ADD, QUANTITY_SUB, QUANTITY_RES)
	SELECT TOT.ID_STORE, TOT.ID_GOODS, TOT.ID_SUPPLIER, 0, 0, 0
	FROM @TOTALS TOT LEFT JOIN STOCK_RECORD SR ON SR.ID_STORE = TOT.ID_STORE
		AND SR.ID_GOODS = TOT.ID_GOODS AND SR.ID_SUPPLIER = TOT.ID_SUPPLIER
	WHERE ID_STOCK_RECORD IS NULL
	
-- ОБНОВЛЕНИЕ ИТОГОВЫХ СТРОК
UPDATE SR SET 
	SR.QUANTITY_ADD = ISNULL(TOT.QUANTITY_ADD, 0),
	SR.QUANTITY_SUB = ISNULL(TOT.QUANTITY_SUB, 0),
	SR.QUANTITY_RES = ISNULL(TOT.QUANTITY_RES, 0)
FROM STOCK_RECORD SR, @TOTALS TOT 
WHERE SR.ID_STORE = TOT.ID_STORE
    AND SR.ID_GOODS = TOT.ID_GOODS AND SR.ID_SUPPLIER = TOT.ID_SUPPLIER

-- ОБНОВЛЕНИЕ ИТОГОВ ПО ПАРТИЯМ
UPDATE LOT SET 
	LOT.QUANTITY_REM = (MOV.QUANTITY_ADD - MOV.QUANTITY_SUB - MOV.QUANTITY_RES),
	LOT.QUANTITY_ADD = MOV.QUANTITY_ADD,
	LOT.QUANTITY_SUB = MOV.QUANTITY_SUB, 
	LOT.QUANTITY_RES = MOV.QUANTITY_RES
FROM (SELECT ID_LOT_GLOBAL, 
		QUANTITY_ADD = SUM(QUANTITY_ADD), 
		QUANTITY_SUB = SUM(QUANTITY_SUB), 
		QUANTITY_RES = SUM(QUANTITY_RES)
	FROM LOT_MOVEMENT GROUP BY ID_LOT_GLOBAL) MOV
WHERE LOT.ID_LOT_GLOBAL = MOV.ID_LOT_GLOBAL

-- ЗАПОЛНЯЕМ ПРОПУЩЕННЫЕ ЦЕНЫ ПРИ ВСТАВКЕ:
-- ПРИ ПРИХОДЕ НЕ ОБЯЗАТЕЛЬНО ЗАПОЛНЯТЬ SVAT_ACC, SUM_ACC 
-- ЕСЛИ ИХ ОСТАВИТЬ НУЛЕВЫМИ, ТРИГЕР ПЕРЕСЧИТАЕТ ПО ЦЕНАМ В ПАРТИИ
-- ПРИ РАСХОДЕ НЕ ОБЯЗАТЕЛЬНО ЗАПОЛНЯТЬ SVAT_SUP, SUM_SUP
-- ЕСЛИ ИХ ОСТАВИТЬ НУЛЕВЫМИ, ТРИГЕР ПЕРЕСЧИТАЕТ ПО ЦЕНАМ В ПАРТИИ
UPDATE LM SET 
	LM.SVAT_SUP = CASE WHEN LM.SVAT_SUP <> 0 THEN LM.SVAT_SUP ELSE
	ABS(LM.QUANTITY_ADD - LM.QUANTITY_SUB - LM.QUANTITY_RES) * LOT.PVAT_SUP END,

	LM.SUM_SUP = CASE WHEN LM.SUM_SUP <> 0 THEN LM.SUM_SUP ELSE
	ABS(LM.QUANTITY_ADD - LM.QUANTITY_SUB - LM.QUANTITY_RES) * LOT.PRICE_SUP END,

	LM.SVAT_ACC = CASE WHEN LM.SVAT_ACC <> 0 THEN LM.SVAT_ACC ELSE
	ROUND(ABS(LM.QUANTITY_ADD - LM.QUANTITY_SUB - LM.QUANTITY_RES) 
	* LOT.PVAT_SAL, 2) END,

	LM.SUM_ACC = CASE WHEN LM.SUM_ACC <> 0 THEN LM.SUM_ACC ELSE
	ROUND(ABS(LM.QUANTITY_ADD - LM.QUANTITY_SUB - LM.QUANTITY_RES) * LOT.PRICE_SAL, 2) END
FROM LOT_MOVEMENT LM
    INNER JOIN LOT ON LOT.ID_LOT_GLOBAL = LM.ID_LOT_GLOBAL
-- КОНЕЦ КОДА ТРИГГЕРА TR_LOT_MOVEMENT

-- ВКЛЮЧИТЬ ТРИГГЕР НА ТАБЛИЦЕ LOT_MOVEMENT
ALTER TABLE LOT_MOVEMENT ENABLE TRIGGER TR_LOT_MOVEMENT

-- СДЕЛАТЬ РАБОТУ, КОТОРУЮ ДЕЛАЕТ В ШТАТНОМ РЕЖИМЕ ТРИГГЕР TR_LOT
/* Штрих-код на партии не нужно генерировать заново
DECLARE @ID_ENTERPRISE_BRANCH_SELF AS BIGINT
SELECT TOP 1 @ID_ENTERPRISE_BRANCH_SELF = ID_GLOBAL FROM ENTERPRISE_BRANCH WHERE IS_SELF = 1
UPDATE LOT 
SET INTERNAL_BARCODE = DBO.FN_BARCODE_GEN(@ID_ENTERPRISE_BRANCH_SELF, LOT.ID_LOT, '20')
WHERE INTERNAL_BARCODE IS NULL
*/

-- СОЗДАТЬ ИМЕНА ПАРТИЙ
UPDATE LOT 
SET LOT.LOT_NAME = ISNULL(I.MNEMOCODE, '') + '/' + CONVERT(VARCHAR(20), LOT.ID_LOT)
FROM LOT 
    INNER JOIN INVOICE I ON LOT.ID_DOCUMENT = I.ID_INVOICE_GLOBAL

-- ВКЛЮЧИТЬ ТРИГГЕР НА ТАБЛИЦЕ LOT
ALTER TABLE LOT ENABLE TRIGGER TR_LOT

-- ВКЛЮЧИТЬ ПРОВЕРКУ ОГРАНИЧЕНИЙ
ALTER TABLE INVOICE_ITEM CHECK CONSTRAINT ALL
ALTER TABLE LOT CHECK CONSTRAINT ALL
ALTER TABLE SERIES CHECK CONSTRAINT ALL

SELECT 'ИМПОРТ ОСТАТКОВ ЗАВЕРШЕН'

--* УДАЛЕНИЕ ВРЕМЕННЫХ ТАБЛИЦ
IF OBJECT_ID('_IMPORT_REMAINS') IS NOT NULL DROP TABLE _IMPORT_REMAINS
IF OBJECT_ID('TEMPDB..#IMPORT_NAKL') IS NOT NULL DROP TABLE #IMPORT_NAKL
SET NOCOUNT OFF

RETURN 0
GO

